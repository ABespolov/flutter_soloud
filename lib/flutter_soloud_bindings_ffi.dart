// this file is not the one generated by ffiGen.
// ffiGen will generate [flutter_soloud_bindings_ffi_TMP.dart]
// from [ffi_gen_tmp.h] file
import 'dart:ffi' as ffi;
import 'package:ffi/ffi.dart';

/// Possible player errors
enum PlayerErrors {
  /// No error
  noError,
  /// Some parameter is invalid
  invalidParameter,
  /// File not found
  fileNotFound,
  /// File found, but could not be loaded
  fileLoadFailed,
  /// DLL not found, or wrong DLL
  dllNotFound,
  /// Out of memory
  outOfMemory,
  /// Feature not implemented
  notImplemented,
  /// Other error
  unknownError,
  /// Player not initialized
  backendNotInited,
}

/// FFI bindings to SoLoud
class FlutterSoLoudFfi {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  FlutterSoLoudFfi(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  FlutterSoLoudFfi.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;


  /// @brief Initialize the player. Must be called before any 
  /// other player functions
  /// @return Returns [PlayerErrors.noError] if success
  PlayerErrors initEngine() {
    return PlayerErrors.values[_initEngine()];
  }

  late final _initEnginePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('initEngine');
  late final _initEngine = _initEnginePtr.asFunction<int Function()>();

  /// @brief Must be called when there is no more need of the 
  /// player or when closing the app
  /// @return
  void dispose() {
    return _dispose();
  }

  late final _disposePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('dispose');
  late final _dispose = _disposePtr.asFunction<void Function()>();

  /// @brief Play a new file
  /// @param completeFileName the complete file path
  /// @return Returns [PlayerErrors.noError] if success
  PlayerErrors playFile(String completeFileName) {
    final e = _playFile(completeFileName.toNativeUtf8().cast<ffi.Char>());
    return PlayerErrors.values[e];
  }

  late final _playFilePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'playFile');
  late final _playFile =
      _playFilePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// @brief Speech
  /// @param textToSpeech
  /// @return Returns [PlayerErrors.noError] if success
  // TODO(me): add other T2S parameters
  PlayerErrors speechText(String completeFileName) {
    final e = _speechText(
      completeFileName.toNativeUtf8().cast<ffi.Char>(),
    );
    return PlayerErrors.values[e];
  }

  late final _speechTextPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'speechText');
  late final _speechText =
      _speechTextPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// @brief Enable or disable visualization
  /// @param enabled
  /// @return
  void setVisualizationEnabled(bool enabled) {
    return _setVisualizationEnabled(
      enabled ? 1 : 0,
    );
  }

  late final _setVisualizationEnabledPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>(
          'setVisualizationEnabled');
  late final _setVisualizationEnabled =
      _setVisualizationEnabledPtr.asFunction<void Function(int)>();

  /// @brief Returns valid data only if VisualizationEnabled is true
  /// @param fft
  /// @return a 256 float array containing FFT data.
  void getFft(ffi.Pointer<ffi.Float> fft) {
    return _getFft(fft);
  }

  late final _getFftPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Float>)>>(
          'getFft');
  late final _getFft =
      _getFftPtr.asFunction<void Function(ffi.Pointer<ffi.Float>)>();

  /// @brief Returns valid data only if VisualizationEnabled is true
  /// @param fft
  /// @return a 256 float array containing wave data.
  void getWave(ffi.Pointer<ffi.Float> wave) {
    return _getWave(wave);
  }

  late final _getWavePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Float>)>>(
          'getWave');
  late final _getWave =
      _getWavePtr.asFunction<void Function(ffi.Pointer<ffi.Float>)>();

  /// @brief return in [samples] a 512 float array.
  /// The first 256 floats represent the FFT frequencies data [0.0~1.0].
  /// The other 256 floats represent the wave data (amplitude) [-1.0~1.0].
  /// @param samples should be allocated and freed in dart side
  /// @return
  void getAudioTexture(ffi.Pointer<ffi.Float> samples) {
    return _getAudioTexture(samples);
  }

  late final _getAudioTexturePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Float>)>>(
          'getAudioTexture');
  late final _getAudioTexture =
      _getAudioTexturePtr.asFunction<void Function(ffi.Pointer<ffi.Float>)>();

  /// @brief Return a floats matrix of 256x512
  /// Every row are composed of 256 FFT values plus 256 wave data
  /// Every time is called, a new row is stored in the
  /// first row and all the previous rows are shifted
  /// up (the last will be lost).
  /// @param samples
  /// @return
  void getAudioTexture2D(ffi.Pointer<ffi.Pointer<ffi.Float>> samples) {
    return _getAudioTexture2D(samples);
  }

  late final _getAudioTexture2DPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<ffi.Float>>)>>('getAudioTexture2D');
  late final _getAudioTexture2D = _getAudioTexture2DPtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<ffi.Float>>)>();

  /// @brief get the sound length in seconds
  /// @return returns sound length in seconds
  double getLength() {
    return _getLength();
  }

  late final _getLengthPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('getLength');
  late final _getLength = _getLengthPtr.asFunction<double Function()>();

  /// @brief seek playing in [time] seconds
  /// @param [time]
  /// @return Returns [PlayerErrors.noError] if success
  PlayerErrors seek(double time) {
    final e = _seek(time);
    return PlayerErrors.values[e];
  }

  late final _seekPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Float)>>('seek');
  late final _seek = _seekPtr.asFunction<int Function(double)>();

  /// @brief get current sound position
  /// @return time in seconds
  double getPosition() {
    return _getPosition();
  }

  late final _getPositionPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function()>>('getPosition');
  late final _getPosition = _getPositionPtr.asFunction<double Function()>();

  /// @brief smooth FFT data.
  /// When new data is read and the values are decreasing, the new value will be
  /// decreased with an amplitude between the old and the new value.
  /// This will resul on a less shaky visualization
  /// @param [smooth] must be in the [0.0 ~ 1.0] range.
  /// 0 = no smooth
  /// 1 = full smooth
  /// the new value is calculated with:
  /// newFreq = smooth * oldFreq + (1 - smooth) * newFreq
  /// @return
  void setFftSmoothing(double smooth) {
    return _setFftSmoothing(smooth);
  }

  late final _setFftSmoothingPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Float)>>(
          'setFftSmoothing');
  late final _setFftSmoothing =
      _setFftSmoothingPtr.asFunction<void Function(double)>();



  
  /// internal test. Does nothing now
  void test() {
    return _test();
  }

  late final _testPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('test');
  late final _test = _testPtr.asFunction<void Function()>();
}

